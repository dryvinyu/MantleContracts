# api-layer Specification

## Purpose
TBD - created by archiving change add-prisma-database-integration. Update Purpose after archive.
## Requirements
### Requirement: Assets Listing API
The system SHALL provide an API endpoint to list and filter assets from the database.

#### Scenario: List all assets without filters
- **WHEN** GET request is made to `/api/assets` without query parameters
- **THEN** it MUST return all assets from the database
- **AND** response MUST include `assets` array, `total` count, `page`, and `pageSize` fields
- **AND** each asset MUST include all fields from the assets table

#### Scenario: Filter assets by type
- **WHEN** GET request is made to `/api/assets?type=treasury`
- **THEN** it MUST return only assets where `type` matches the parameter
- **AND** valid types are: `treasury`, `real-estate`, `credit`, `cash`
- **AND** response total MUST reflect filtered count

#### Scenario: Filter assets by minimum APY
- **WHEN** GET request is made to `/api/assets?minAPY=7.0`
- **THEN** it MUST return only assets where `apy >= 7.0`
- **AND** the parameter MUST be parsed as a numeric value
- **AND** invalid numeric values MUST be ignored (no filter applied)

#### Scenario: Filter assets by maximum risk score
- **WHEN** GET request is made to `/api/assets?maxRisk=30`
- **THEN** it MUST return only assets where `riskScore <= 30`
- **AND** the parameter MUST be parsed as an integer
- **AND** invalid values MUST be ignored (no filter applied)

#### Scenario: Combine multiple filters
- **WHEN** GET request is made with multiple filter parameters
- **THEN** all applicable filters MUST be combined with AND logic
- **AND** assets MUST match all specified criteria to be included

### Requirement: Asset Detail API
The system SHALL provide an API endpoint to retrieve detailed asset information including user position.

#### Scenario: Retrieve asset with user position
- **WHEN** GET request is made to `/api/assets/[id]`
- **THEN** it MUST fetch the asset from the database by ID
- **AND** it MUST fetch the user's holdings for that asset
- **AND** response MUST include `asset` object and `userPosition` object
- **AND** `userPosition` MUST contain `shares` and `amount` (shares × price)

#### Scenario: Asset not found
- **WHEN** GET request is made with non-existent asset ID
- **THEN** it MUST return 404 status code
- **AND** response body MUST include `{ error: 'Asset not found' }`

#### Scenario: User has no position in asset
- **WHEN** user has zero shares of the requested asset
- **THEN** `userPosition.shares` MUST be 0
- **AND** `userPosition.amount` MUST be 0
- **AND** the asset details MUST still be returned

### Requirement: Portfolio Summary API
The system SHALL provide an API endpoint to retrieve the user's complete portfolio with calculated metrics.

#### Scenario: Calculate portfolio with holdings
- **WHEN** GET request is made to `/api/portfolio`
- **THEN** it MUST fetch the user's portfolio and all holdings from the database
- **AND** it MUST include asset details for each holding
- **AND** response MUST include `portfolio` object with `userId`, `totalAUM`, `weightedAPY`, `riskScore`, `positions`, and `allocation`

#### Scenario: Calculate weighted APY
- **WHEN** portfolio has multiple positions
- **THEN** `weightedAPY` MUST be calculated as sum of (position_value / total_value) × asset_apy for each position
- **AND** cash MUST NOT contribute to weighted APY calculation
- **AND** result MUST be rounded to 2 decimal places

#### Scenario: Calculate portfolio risk score
- **WHEN** portfolio has multiple positions
- **THEN** `riskScore` MUST be calculated as weighted average of asset risk scores by position value
- **AND** result MUST be rounded to nearest integer
- **AND** cash MUST have risk score of 0

#### Scenario: Calculate asset allocation
- **WHEN** portfolio positions are aggregated
- **THEN** `allocation` MUST be an object mapping asset type labels to total values
- **AND** allocation MUST include `Cash` with the portfolio cash balance
- **AND** asset types MUST be mapped to labels: `Treasury`, `Real Estate`, `Credit`, `Cash`

#### Scenario: Empty portfolio
- **WHEN** user has no holdings
- **THEN** `totalAUM` MUST equal cash balance only
- **AND** `weightedAPY` MUST be 0
- **AND** `riskScore` MUST be 0
- **AND** `positions` MUST be an empty array
- **AND** `allocation` MUST only contain `Cash` with cash balance

### Requirement: Transaction Creation API
The system SHALL provide an API endpoint to create transaction records in the database.

#### Scenario: Create transaction record
- **WHEN** POST request is made to `/api/transactions`
- **THEN** it MUST create a new transaction record in the database
- **AND** response MUST include `transaction` object with `id`, `status`, `txHash`, and `timestamp`
- **AND** `id` MUST be auto-generated by the database
- **AND** `timestamp` MUST be set to current time

#### Scenario: Transaction persists to database
- **WHEN** a transaction is created
- **THEN** it MUST be immediately queryable from the database
- **AND** all transaction fields MUST be stored correctly
- **AND** database constraints MUST be validated (e.g., non-negative amounts)

### Requirement: API Backward Compatibility
The system SHALL maintain exact API response formats from the previous mock implementation.

#### Scenario: Response shapes match mock APIs
- **WHEN** any API endpoint is called
- **THEN** the response JSON structure MUST match the previous mock API format
- **AND** field names MUST remain unchanged
- **AND** field types MUST remain unchanged
- **AND** nested object structures MUST remain unchanged

#### Scenario: Frontend components work without changes
- **WHEN** database-backed APIs are deployed
- **THEN** existing frontend components MUST function without modification
- **AND** data transformations MUST happen server-side if needed
- **AND** no TypeScript errors MUST occur in frontend code consuming APIs

### Requirement: Asset Creation API
The system SHALL provide an API endpoint to create new investment assets in the database.

#### Scenario: Create asset with valid data
- **WHEN** POST request is made to `/api/assets` with valid asset data in request body
- **THEN** it MUST validate all required fields are present
- **AND** it MUST validate all field values meet database constraints
- **AND** it MUST check that asset ID does not already exist
- **AND** it MUST create the asset record in the database
- **AND** it MUST return 201 status code
- **AND** response MUST include the created asset object matching GET response format

#### Scenario: Missing required fields
- **WHEN** POST request is made with missing required fields
- **THEN** it MUST return 400 status code
- **AND** response MUST include error message listing missing fields
- **AND** no asset MUST be created in the database

#### Scenario: Invalid field values
- **WHEN** POST request contains invalid field values (e.g., negative APY, risk score > 100)
- **THEN** it MUST return 400 status code
- **AND** response MUST include error message describing validation failures
- **AND** no asset MUST be created in the database

#### Scenario: Duplicate asset ID
- **WHEN** POST request contains an asset ID that already exists
- **THEN** it MUST return 409 status code
- **AND** response MUST include error message indicating duplicate ID
- **AND** no asset MUST be created in the database

#### Scenario: Invalid enum values
- **WHEN** POST request contains invalid enum values for type or status
- **THEN** it MUST return 400 status code
- **AND** response MUST include error message listing valid enum values
- **AND** no asset MUST be created in the database

#### Scenario: Required fields validation
- **WHEN** POST request is validated
- **THEN** required fields MUST include: id, name, type, apy, durationDays, riskScore, yieldConfidence, aumUsd, price, status, nextPayoutDate
- **AND** optional fields MAY include: description, tokenAddress, distributorAddress
- **AND** all required fields MUST be non-empty (where applicable)

#### Scenario: Numeric range validation
- **WHEN** POST request contains numeric fields
- **THEN** apy MUST be >= 0
- **AND** durationDays MUST be > 0
- **AND** riskScore MUST be between 0 and 100 (inclusive)
- **AND** yieldConfidence MUST be between 0 and 100 (inclusive)
- **AND** aumUsd MUST be >= 0
- **AND** price MUST be >= 0
- **AND** invalid values MUST result in 400 error response

#### Scenario: Date format validation
- **WHEN** POST request contains nextPayoutDate field
- **THEN** it MUST be a valid date string (ISO 8601 format or YYYY-MM-DD)
- **AND** invalid date format MUST result in 400 error response

